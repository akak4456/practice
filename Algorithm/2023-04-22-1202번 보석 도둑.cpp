#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <utility>
using namespace std;

vector<pair<int, int>> VandM;
multiset<int> C;

int main() {
	int N, K;
	cin >> N >> K;
	for (int i = 0; i < N; i++) {
		int m, v;
		cin >> m >> v;
		VandM.push_back(make_pair(v, m));
	}
	for (int i = 0; i < K; i++) {
		int c;
		cin >> c;
		C.insert(c);
	}
	/*
	일단은 가방이 하나만 있는 경우를 생각해보자. 그럼 어떻게 될까?
	아무튼 보석의 최대 가격을 구해야만 겠지...
	일단 무게랑 가치를 고려해봐야만 한다.
	그럼 일단 크게 4가지 경우가 있을 것이다.
	1) 무게도 작고 가치도 작은 것
	2) 무게는 작지만 가치는 큰 것
	3) 무게는 크지만 가치는 작은 것
	4) 무게도 크고 가치도 큰것
	그럼 여기에서 확실히 거를 수 있는 것은 3) 무게는 크지만 가치는 작은 것이다.
	그리고 되도록이면 2) 무게는 작지만 가치는 큰 것을 고르는 것이 나을 것이다.
	그럼 여기에서 고민이 되는 것은 4) 무게도 크고 가치도 큰것과 1) 무게도 작고 가치도 작은 것을 어떻게
	선택하냐는 것이다. 무게가 배수 관계라면 문제 풀이에 쉬었겠지만 그런 조건은 찾아볼 수 없었다.
	근데 사실 이런 것은 만들면 그만 아닌가? 그러니까 [(무게, 가치)] = (100, 80), (70, 50), (30, 40) 이 있다고 해보자
	그럼 당연히 (100, 80) 을 고르는 것보다 (70, 50), (30, 40) 두개를 고르는 것이 이득일 것이다. 왜냐하면 무게에 대한
	제한만 있을 뿐이지, 갯수에 대한 제한은 없기 때문이다. 그러니까 사실 무조건 가치가 높은 것을 우선으로 뽑는다고 해서
	최적해가 나오는 것은 아니다. 근데 이렇게 생각할 수도 있는 것 아닌가? 저 가방 하나의 무게가 100 이라고 할 때
	(100, 80) 을 고르는 경우랑 (100, 80) 을 고르지 않는 경우를 나누어서 생각하는 거지. 아닌가? 그럼 시간 복잡도가 너무
	커져버리나? 모든 무게를 다 채우는 것이 문제의 핵심은 아니다. 핵심은 보석의 가치의 합을 최대한 크게 만드는 것이다.
	아 내가 문제를 오해했다. 한개의 가방에는 오직 한개의 보석만 들어간다는 것을 놓쳤다. 사실 저렇게 따지면 저건 그리디가
	아니지. 일단 너무나 당연하겠지만 한개의 가방에 보석을 하나도 넣지 않는 것보다 당연히 보석을 하나라도 넣는 것이 이득이다.
	그러나 N > K 보다 크다는 보장은 없으니 불행히도 가방에 보석이 하나도 들어가지 않을 가능성도 있다.한편 N > K 라고 해도
	보석이 모두 가방보다 크다면 들어갈 수가 없기도 하다. 그렇다면 따져보자. 가방의 무게가 3, 10 이렇게 있다고 하자. 그렇다면
	우선 가방의 무게가 3인 것부터 채우는 것이 이득아닐까? 왜냐하면 1) 어차피 가방에는 어떤 것이든 들어가는 것이 이득이기 때문이다.
	2) 가방에는 최대 1개의 보석만 들어가기 때문이다. 3) 보석의 무게가 3, 4, 5 와 같이 나온다고 해보자. 그럼 무게가 3인 보석은 가방의
	무게가 3, 10에 들어가겠지만 무게가 4, 5인 것은 가방의 무게가 10인 것에만 들어가기 때문이다.
	따라서 아래와 같은 로직을 작성하였다.
	1) M, K 를 pair 로 묶는다.
	2) 그 pair vector 를 M의 오름차순으로 정렬한다.
	3) C 배열도 마찬가지로 오름차순으로 정렬한다.
	4) pair vector 의 M이 C[0] 보다 작으면서 가치가 제일 큰것, C[1] 보다 작으면서 가치가 제일 큰 것을 찾는다.
	라고 생각했는데 두번째 예제를 보니 이건 다소 잘못된 생각인 것 같다.
	그럼
	4) pair vector 의 M이 C[K-1] 보다 작으면서 가치가 제일 큰것, C[K-2] 보다 작으면서 가치가 제일 큰 것을 찾는다.
	와 같이 생각하는 것은 어떨까? 그러니까 어차피 가방에는 1개의 보석밖에 안들어간단 말이야. 그럼 일단 무게가 가장 큰 가방부터 따져 보는거지.
	일단 가치가 제일 큰것부터 어떻게든 우겨넣는게 낳겠지... 단 그거의 가방의 무게는 최대한 작은쪽으로 가는게 좋을것 같다. 이렇게 하면 되겠군.
	현재 이와 같이 구현하니
	3 3
	1 65
	5 23
	2 99
	10
	2
	1
	에서 예외가 발생한다.
	저건 해결했는데 여전히 틀렷다가 뜨는 구만!
	4 3
	10 100
	10 10
	100 10
	100 100
	10
	100
	100
	에서도 예외가 발생한다.
	*/
	sort(VandM.begin(), VandM.end());
	long long int sol = 0;
	for (int i = N - 1; i >= 0; i--) {
		auto it = C.lower_bound(VandM[i].second);
		// cout << VandM[i].first << ' ' << VandM[i].second << endl;
		// cout << "C의 size 는 " << C.size() << endl;
		if(it != C.end()) {
			// cout << "C의 무게는 " << (*it) << endl;
			C.erase(it);
			sol += VandM[i].first;
		}
	}
	cout << sol << endl;
	return 0;
}